<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Window resize</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <link rel="stylesheet" type="text/css" href="styles/style.css">
    <script src='vendor/state-machine.min.js'></script>
    <script src="vendor/three.min.js"></script>
    <script src="vendor/extras/BoxLineGeometry.js"></script>
    <script src="vendor/extras/WebVR.js"></script>
  </head>
  <body>
    <script>

    var windowState = new StateMachine({
      init: 'idle',
      transitions: [
        { name: 'resize', from: 'idle', to: 'resizing' },
        { name: 'move', from: 'idle', to: 'moving' },
        { name: 'reset', from: ['resizing', 'moving'], to: 'idle'}],
      data: {
        width: 3,
        height: 2,
        intersection: null,
        controller: null
      },
      methods: {
        setSize: function(w, h) {
          this.width = w;
          this.height = h;
        },
        setControllerIntersection: function(controller, intersection) {
          if (this.controller && this.intersection) {
            return;
          }
          this.controller = controller;
          this.intersection = intersection;
        },
        clearControllerIntersection: function() {
          this.controller = null;
          this.intersection = null;
        }
      }
    });

    const rWindow = function (width, height) {
      var object3D;
      var windowMesh;
      var resizeControl;
      var moveControl;
      var interactables;

      var state = this.state = windowState;
      this.state.observe('onReset', this.state.clearControllerIntersection);

      this.controllers = [];
      this.isSelecting = false;

      object3D = this.object3D = new THREE.Group(); 
      this.raycaster = new THREE.Raycaster();
      this.tempMatrix = new THREE.Matrix4();
      windowMesh = this.windowMesh = this.makeWindowMesh();
      resizeControl = this.resizeControl = this.makeResizeControl();
      moveControl = this.moveControl = this.makeMoveControl();

      // UI elements which rayaster will respond to.
      interactables = this.interactables = [];
      interactables.push(resizeControl);
      interactables.push(moveControl);

      object3D.add(windowMesh);
      object3D.add(resizeControl);
      object3D.add(moveControl);

      if (width && height) {
        state.setSize(width, height);
      }

      return this;
    }

    rWindow.prototype.makeWindowMesh = function () {
      var geo, mat, mesh;
      var width = this.width;
      var height = this.height;
      geo = new THREE.PlaneGeometry( 1, 1, 1 );
      mat = new THREE.MeshBasicMaterial({color: 0xc0c0c0, wireframe: true});
      mesh = new THREE.Mesh( geo, mat );
      mesh.scale.set(width, height, 1);
      return mesh;
    }

    rWindow.prototype.makeResizeControl = function () {
      var geo, mat, mesh;
      geo = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
      mat = new THREE.MeshBasicMaterial({color: 0x00ff00});
      mesh = new THREE.Mesh( geo, mat );
      mesh.name = 'resizeHandle';
      return mesh;
    }

    rWindow.prototype.makeMoveControl = function () {
      var geo, mat, mesh;
      geo = new THREE.BoxGeometry( 1, 0.2, 0.2 );
      mat = new THREE.MeshBasicMaterial({color: 0x00ffff});
      mesh = new THREE.Mesh( geo, mat );
      mesh.name = 'repositionHandle';
      return mesh;
    }

    rWindow.prototype.registerController = function(controller) {
      var controllers = this.controllers;
      if (controllers.indexOf(controller) != -1) {
        return;
      }

      controllers.push(controller);

      controller.addEventListener('selectstart', this.controllerSelectStart.bind(this));
      controller.addEventListener('selectend', this.controllerSelectEnd.bind(this));
    }

    rWindow.prototype.controllerSelectStart = function (e) {
      this.isSelecting = true;
    }

    rWindow.prototype.controllerSelectEnd = function (e) {
      this.isSelecting = false;
    }

    rWindow.prototype.updateInteractionState = function () {
      var intersection = null;
      for (var controller of this.controllers) {
        var tempMatrix = this.tempMatrix;
        var raycaster = this.raycaster;
        var interactables = this.interactables;

        tempMatrix.identity().extractRotation( controller.matrixWorld );
        raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
        raycaster.ray.direction.set( 0, 0, -1 ).applyMatrix4( tempMatrix );

        var intersections = raycaster.intersectObjects(interactables);

        // trigger down on UI element
        if (intersections.length > 0 && this.isSelecting) {
          var intersection = intersections[0];
          var isIdle = windowState.is('idle');
          this.state.setControllerIntersection(controller, intersection);
          if (intersection.object == this.resizeControl && isIdle) {
            this.state.resize();
          }

          if (intersection.object == this.moveControl && isIdle) {
            this.state.move();
          }
          break;
        }

        // trigger up
        if (!this.isSelecting && !windowState.is('idle')) {
          this.state.reset();
        }
      }
    }

    rWindow.prototype.onResize = function () {
      var intersection = this.state.intersection;
      var controller = this.state.controller;
      var resizeControl = this.resizeControl;
      var object3D = this.object3D;

      // set a cursor to UI element intersection and adjust control and window size to cursor position.
      var cursorPosition = new THREE.Vector3(0, 0, intersection.distance * -1);
      cursorPosition.applyMatrix4(controller.matrixWorld);
      cursorPosition.copy(object3D.worldToLocal(cursorPosition));

      resizeControl.position.set(cursorPosition.x, cursorPosition.y, resizeControl.position.z);
      this.state.width = cursorPosition.x * 2;
      this.state.height = cursorPosition.y * -2;
    }

    rWindow.prototype.onMove = function () {
      var intersection = this.state.intersection;
      var controller = this.state.controller;
      var moveControl = this.moveControl;
      var object3D = this.object3D;

      var cursorPosition = new THREE.Vector3(0, 0, intersection.point.z);
      cursorPosition.applyMatrix4(controller.matrixWorld);
      cursorPosition.add(new THREE.Vector3(0, -this.state.height / 2, 0));
      object3D.position.copy(cursorPosition);
    }

    rWindow.prototype.update = function () {
      var windowMesh = this.windowMesh;
      var resizeControl = this.resizeControl;
      var moveControl = this.moveControl;

      // set window size
      windowMesh.scale.set(this.state.width, this.state.height, 1);
      // set ui control positions
      resizeControl.position.x = this.state.width / 2;
      resizeControl.position.y = this.state.height / 2 * -1;
      resizeControl.position.z = 0;      
      moveControl.position.x = 0;
      moveControl.position.y = this.state.height / 2;
      moveControl.position.z = 0;

      // update window state interactions
      this.updateInteractionState();

      if (this.state.is('resizing')) {
        this.onResize();
      }
      if (this.state.is('moving')) {
        this.onMove();
      }
    }
    </script>
    <script>
      var container;
      var camera, scene, renderer;
      var controller1, controller2;

      var room;

      var count = 0;
      var radius = 0.08;
      var normal = new THREE.Vector3();
      var relativeVelocity = new THREE.Vector3();

      var resizeable;

      init();
      animate();

      function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x00283D );

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );

        room = new THREE.LineSegments(
          new THREE.BoxLineGeometry( 6, 6, 6, 10, 10, 10 ),
          new THREE.LineBasicMaterial( { color: 0x00A6FF } )
        );
        room.geometry.translate( 0, 3, 0 );
        //scene.add( room );

        var light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
        light.position.set( 1, 1, 1 );
        scene.add( light );

        //
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );

        //
        document.body.appendChild( WEBVR.createButton( renderer ) );

        controller1 = renderer.vr.getController( 0 );
        scene.add( controller1 );

        controller2 = renderer.vr.getController( 1 );
        scene.add( controller2 );

        // helpers
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 5 ], 3 ) );
        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

        var material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

        controller1.add( new THREE.Line( geometry, material ) );
        controller2.add( new THREE.Line( geometry, material ) );

        var controllerMat = new THREE.MeshBasicMaterial({color: 0xec2f2f});
        var controllerGeo = new THREE.BoxGeometry( 0.07, 0.04, 0.2 );
        var controllerMesh1 = new THREE.Mesh(controllerGeo, controllerMat);
        var controllerMesh2 = new THREE.Mesh(controllerGeo, controllerMat);
        controller1.add(controllerMesh1);
        controller2.add(controllerMesh2);

        //
        window.addEventListener( 'resize', onWindowResize, false );

        // resizeable window
        resizeable = new rWindow();
        resizeable.object3D.position.z = -3;
        resizeable.object3D.position.y = 1.5;
        resizeable.registerController(controller1);
        resizeable.registerController(controller2);

        scene.add(resizeable.object3D);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function animate() {
        renderer.setAnimationLoop( render );
      }

      function render() {
        resizeable.update();
        renderer.render( scene, camera );
      }
    </script>
  </body>
</html>
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Window resize</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <link rel="stylesheet" type="text/css" href="styles/style.css">
    <script src="vendor/three.min.js"></script>
    <script src="vendor/extras/BoxLineGeometry.js"></script>
    <script src="vendor/extras/WebVR.js"></script>
  </head>
  <body>
    <script>
    // screen
    const ResizeableWindow = function(w, h) {
      this.width = w;
      this.height = h;
      this.controllers = [];
      this.interactables = [];
      this.isSelecting = false;
      this.object3D = new THREE.Group();
      var object3D = this.object3D;

      this.windowState = {
        screenPosition: null,
        screenScale: null,
        handlePosition: null
      }


      var screen = this.makeScreen();
      this.screen = screen;
      object3D.add(screen);
      
      var handle = this.makeHandle();
      handle.position.x = w / 2;
      handle.position.y = h / 2 * -1;
      this.handle = handle;
      this.interactables.push(handle);
      object3D.add(handle);

      var reposition = this.makeReposition();
      this.reposition = reposition;
      this.updateRepositionHandle();
      this.interactables.push(reposition);
      object3D.add(reposition);

      var cursor = this.makeCursor();
      this.cursor = cursor;
      object3D.add(cursor);
      
      this.currentController = null;
      this.startIntersection = null;

      this.raycaster = new THREE.Raycaster();
      this.tempMatrix = new THREE.Matrix4();

      return this;
    }

    ResizeableWindow.prototype.makeCursor = function () {
      // var geo, mat, mesh;
      // geo = new THREE.SphereGeometry( 0.2 );
      // mat = new THREE.MeshBasicMaterial({color: 0xf34b1b, wireframe: true});
      // mesh = new THREE.Mesh( geo, mat );
      return new THREE.Group();
    }

    ResizeableWindow.prototype.makeScreen = function() {
        var geo, mat, mesh;
        var width = this.width;
        var height = this.height;
        geo = new THREE.PlaneGeometry( 1, 1, 1 );
        mat = new THREE.MeshBasicMaterial({color: 0xc0c0c0, wireframe: true});
        mesh = new THREE.Mesh( geo, mat );
        mesh.scale.set(width, height, 1);
        return mesh;
    }

    ResizeableWindow.prototype.makeReposition = function() {
        var geo, mat, mesh;
        geo = new THREE.BoxGeometry( 1, 0.2, 0.2 );
        mat = new THREE.MeshBasicMaterial({color: 0x00ffff});
        mesh = new THREE.Mesh( geo, mat );
        mesh.name = 'repositionHandle';
        return mesh;
    }

    ResizeableWindow.prototype.makeHandle = function() {
        var geo, mat, mesh;
        geo = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
        mat = new THREE.MeshBasicMaterial({color: 0x00ff00});
        mesh = new THREE.Mesh( geo, mat );
        mesh.name = 'resizeHandle';
        return mesh;
    }

    ResizeableWindow.prototype.registerController = function(controller) {
      if (this.controllers.indexOf(controller) != -1) {
        return;
      }

      this.controllers.push(controller);

      controller.addEventListener('selectstart', this.controllerSelectStart.bind(this));
      controller.addEventListener('selectend', this.controllerSelectEnd.bind(this));
    }

    ResizeableWindow.prototype.controllerSelectStart = function(e) {
      this.isSelecting = true;
    }

    ResizeableWindow.prototype.controllerSelectEnd = function(e) {
      this.isSelecting = false;
    }

    ResizeableWindow.prototype.saveWindowState = function() {
      var screenPosition = new THREE.Vector3().copy(this.screen.position);
      var screenScale = new THREE.Vector3().copy(this.screen.scale);
      var handlePosition = new THREE.Vector3().copy(this.handle.position);

      this.windowState.screenPosition = screenPosition;
      this.windowState.screenScale = screenScale;
      this.windowState.handlePosition = handlePosition;
      return this.windowState;
    }

    ResizeableWindow.prototype.clearWindowState = function () {
      var windowState = this.windowState;
      windowState.screenScale = null;
      windowState.handlePosition = null;
      windowState.handlePosition = null;
    }

    ResizeableWindow.prototype.resizeHandle = function() {
      var isResize = this.startIntersection && this.startIntersection.object.name == 'resizeHandle';
      
      // trigger up
      if (this.startIntersection && !this.isSelecting && isResize) {
        this.clearWindowState();
      }

      // update until trigger is up
      if (this.startIntersection && isResize) {
        var screen = this.screen;

        // move cursor to UI element intersection
        var cursorPosition = new THREE.Vector3(0, 0, this.startIntersection.distance * -1);
        cursorPosition.applyMatrix4(this.currentController.matrixWorld);
        this.cursor.position.copy(this.object3D.worldToLocal(cursorPosition));

        this.saveWindowState();

        // set handle position
        this.handle.position.set(cursorPosition.x, cursorPosition.y, this.handle.position.z);

        // set screen based off of handle position
        var handleDiff = new THREE.Vector3().subVectors(this.handle.position, this.windowState.handlePosition);
        var screenScaleX = this.windowState.screenScale.x * (1 + (handleDiff.x / this.windowState.handlePosition.x));
        var screenScaleY = this.windowState.screenScale.y * (1 + (handleDiff.y / this.windowState.handlePosition.y));

        screen.scale.set(screenScaleX,
          screenScaleY,
          screen.scale.z);

        // set reposition
        this.updateRepositionHandle();
      }
    }

    ResizeableWindow.prototype.repositionHandle = function () {
      var isRepositioning = this.startIntersection && this.startIntersection.object.name == 'repositionHandle';

      // trigger up
      if (this.startIntersection && !this.isSelecting && isRepositioning) {
        this.clearWindowState();
      }

      // we're interacting with UI element
      if (this.startIntersection && isRepositioning) {
        // move cursor to UI element intersection
        var cursorPosition = new THREE.Vector3(0, 0, this.startIntersection.distance * -1);
        cursorPosition.applyMatrix4(this.currentController.matrixWorld);
        this.cursor.position.copy(this.object3D.worldToLocal(cursorPosition));

        this.saveWindowState();

        // reposition window
        if (!this.screenCursorDiff) {
          this.screenCursorDiff = new THREE.Vector3().subVectors(this.screen.position, this.reposition.position);
        }
        this.screen.position.copy(this.cursor.position.add(this.screenCursorDiff));
        this.reposition.position.set(cursorPosition.x, cursorPosition.y, cursorPosition.z);
        
        var screenPositionDiff = new THREE.Vector3().subVectors(this.screen.position, this.windowState.screenPosition);
        this.handle.position.set(this.windowState.handlePosition.x + screenPositionDiff.x,
          this.windowState.handlePosition.y + screenPositionDiff.y,
          this.windowState.handlePosition.z + screenPositionDiff.z);
      }
    }

    ResizeableWindow.prototype.updateRepositionHandle = function() {
      var reposition = this.reposition;
      var positionX = 0;
      var positionY = this.height / 2;
      if (this.windowState && this.windowState.screenScale) {
        positionY *= (this.windowState.screenScale.y / 2);
      }
      reposition.position.x = positionX;
      reposition.position.y = positionY;
    }

    ResizeableWindow.prototype.update = function() {
      // save point which user interacts with UI element, update UI element until user releases select, then save end point.
      var intersection = null;

      for (var controller of this.controllers) {
        var tempMatrix = this.tempMatrix;
        var raycaster = this.raycaster;
        var interactables = this.interactables;

        tempMatrix.identity().extractRotation( controller.matrixWorld );
        raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
        raycaster.ray.direction.set( 0, 0, -1 ).applyMatrix4( tempMatrix );

        var intersections = raycaster.intersectObjects(interactables);

        // trigger down on UI element
        if (intersections.length > 0 && this.isSelecting) {
          var intersection = intersections[0];
          
          if (!this.startIntersection) {
            this.startIntersection = intersection;
            this.currentController = controller;

            break;
          }
        }
      }

      // trigger up
      if (this.startIntersection && !this.isSelecting) {
        this.startIntersection = false;
        this.currentController = null;
      }

      this.resizeHandle();
      this.repositionHandle();
    }

    </script>
    <script>
      var container;
      var camera, scene, renderer;
      var controller1, controller2;

      var room;

      var count = 0;
      var radius = 0.08;
      var normal = new THREE.Vector3();
      var relativeVelocity = new THREE.Vector3();


      var myWindow;

      init();
      animate();

      function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x00283D );

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );

        room = new THREE.LineSegments(
          new THREE.BoxLineGeometry( 6, 6, 6, 10, 10, 10 ),
          new THREE.LineBasicMaterial( { color: 0x00A6FF } )
        );
        room.geometry.translate( 0, 3, 0 );
        //scene.add( room );

        var light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
        light.position.set( 1, 1, 1 );
        scene.add( light );

        //
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.vr.enabled = true;
        container.appendChild( renderer.domElement );

        //
        document.body.appendChild( WEBVR.createButton( renderer ) );

        controller1 = renderer.vr.getController( 0 );
        scene.add( controller1 );

        controller2 = renderer.vr.getController( 1 );
        scene.add( controller2 );

        // helpers
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 5 ], 3 ) );
        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

        var material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

        controller1.add( new THREE.Line( geometry, material ) );
        controller2.add( new THREE.Line( geometry, material ) );

        var controllerMat = new THREE.MeshBasicMaterial({color: 0xec2f2f});
        var controllerGeo = new THREE.BoxGeometry( 0.07, 0.04, 0.2 );
        var controllerMesh1 = new THREE.Mesh(controllerGeo, controllerMat);
        var controllerMesh2 = new THREE.Mesh(controllerGeo, controllerMat);
        controller1.add(controllerMesh1);
        controller2.add(controllerMesh2);

        //
        window.addEventListener( 'resize', onWindowResize, false );

        // resizeable window stuff.
        myWindow = new ResizeableWindow(3, 2);
        myWindow.object3D.position.z = -3;
        myWindow.object3D.position.y = 1.5;

        myWindow.registerController(controller1);
        myWindow.registerController(controller2);

        scene.add(myWindow.object3D);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function animate() {
        renderer.setAnimationLoop( render );
      }

      function render() {
        myWindow.update();
        renderer.render( scene, camera );
      }
    </script>
  </body>
</html>